/*-------------------------------------------------------------------------
 *
 * tsb.h
 *
 *
 *
 * Copyright (c) 2003, Regents of the University of California
 *
 * $Id: tsb.h,v 1.12 2004/01/19 21:37:57 mashah Exp $
 *
 *-------------------------------------------------------------------------
 */
#ifndef TSB_H
#define TSB_H

#include "executor/tuptable.h"
#include "rqueue/rqdest.h"

#define TSB_PRODUCED	   1
#define TSB_PRIMARY		   2
#define TSB_SECONDARY	   4

#define INV_TSB_ENTRY(tsb_ent)           ((tsb_ent)->dmask < 0)
#define TSB_FULL(tsb)					 ((tsb)->size == (tsb)->max_size)
#define TSB_PART_EMPTY(tsb, part_no)	 ((tsb)->table[part_no]->dmask < 0)
#define TSB_PRIM_PART_EMPTY(tsb, part_no)	  ((tsb)->p_head[part_no]->dmask < 0)
#define TSB_SEC_PART_EMPTY(tsb, part_no)	  ((tsb)->s_head[part_no]->dmask < 0)
#define TSB_LAST_ENT_EMPTY(tsb, part_no)      ((tsb)->last_ents[part_no] == NULL)

#define TSB_EMPTY(tsb)                   ((tsb)->size == (tsb)->num_parts)

#define PUNCTUATION		-100

typedef struct TSB_Entry
{

	struct TSB_Entry *next;
	struct TSB_Entry *prev;
	int			seqnum;			/* So I don't need to get it again */
	HeapTuple				htup;	/* Contains the sequence number	*/
	result		rtup;
	int			dmask;			/* Done mask */

}	TSB_Entry;

typedef struct TSB
{

	int			max_size;
	int			size;			/* Number of tuples in the TSB */
	int			num_parts;		/* Number of partitions */

	int		   *counts;			/* Counts in each partition */
	TSB_Entry **table;			/* Points to the tail of the entries */
 
	/* These all point to the first un-processed or un-acknowledged item */
	TSB_Entry **prod_ack;		/* Last thing generated by the operator
								 * below */
	TSB_Entry **prim_ack;		/* What has been acked by primary			  */
	TSB_Entry **sec_ack;		/* What has been acked by secondary			  */

	TSB_Entry **p_head;			/* Where the primary connection left off   */
	TSB_Entry **s_head;			/* Where the secondary connection left off */

	/* Free list pointers */
	TSB_Entry  *f_head;
	TSB_Entry  *f_tail;

	TSB_Entry **last_ents;      /* Reserved for the last ones */

	bool        shouldFree;     /* Should I free the tuple on delete? */
}	TSB;

extern void advance_head_TSB(TSB *tsb, int part_no, int mask);
extern void reset_head_TSB(TSB *tsb, int part_no, int mask);
extern void get_head_TSB(TSB *tsb, TupleTableSlot *slot, int part_no, int mask);
extern void get_head_TSB_r(TSB *tsb, result *r, int part_no, int mask);
extern bool put_ack_TSB(TSB *tsb, TupleTableSlot *slot,
						int seqno, int part_no, int mask, int fmask);
extern void reset_ack_TSB(TSB *tsb, int partno, int mask);
extern bool insert_marker_end_TSB(TSB *tsb, result *r, int part_no);
extern bool append_result_TSB(TSB *tsb, result *r, int seq_no, int mask, int part_no);

extern bool insert_marker_start_TSB(TSB *tsb, result *r, int part_no, int mask);
extern void init_TSB(TSB *tsb, int nparts, int max);
extern int  get_unack_seqno_TSB(TSB *tsb, int part_no, int mask);
extern void dump_seq_TSB(TSB *tsb);
extern void dump_seq_TSB_part(TSB *tsb, int i);

extern void ack_all_TSB(TSB *node, int partno, int mask, int del_mask);
extern void reset_cursors_TSB(TSB *tsb, int partno, int mask);

extern void ack_to_marker_TSB(TSB *tsb, int partno, int mask, int del_mask);
extern int  chain_len_prev(TSB_Entry *t);
extern int  chain_len_next(TSB_Entry *t);
extern void dump_chain(TSB_Entry *t);

extern void return_last_ent_TSB(TSB *tsb, int part_no);

extern void permute_tsb_parts(TSB *tsb, int *perm_map);

#endif   /* TSB_H */
